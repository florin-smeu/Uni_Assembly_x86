Nume: Smeu Florin-Ion
Grupa: 322CD

			
		 	     ===================
			     TEMA 3 - Exploatare
			     ===================


	
	TASK 1 - Analiza statica si dinamica
	====================================

In cadrul acestui task am analizat static executabilul, folosind IDA Free si 
dinamic, utilizand GDB. De asemenea, am determinat un serial key valid pentru 
optiunea "0" a programului. Pentru aceasta, functiile pe care le-am analizat au
fost cele de la adresele urmatoare:
	
	.text:0x080489A9 - MAIN
	----------------
	Afiseaza mesajul text de bun-venit, precum si mesajele text 
corespunzatoare optiunilor care pot fi alese de utilizator. Pentru a afisa 
mesajul de bun-venit ("(...) Welcome to the vault (...)"), este apelata o 
functie care decripteaza acest mesaj. Aceasta functie se gaseste la adresa 
.text:0x08048635 (DECRYPT) si va fi documentata in amanunt mai jos. Textul 
decriptat este afisat de functia de adresa .text:0x0848871 (PRINT_WELCOME).
	De asemenea, textul corespunzator optiunilor ce pot fi alese este 
decriptat de functia DECRYPT. Ulterior se apeleaza functia de la adresa 
.text:0x08048883 (PRINT_OPTIONS) (afiseaza textul decriptat anterior) si cea de
la adresa .text:0x0804893A (CHOOSE_OPTION). Aceste ultime doua apeluri se 
petrec in loop, responsabilitatea iesirii din program revenind altei functii.

	.text:0x08048635 - DECRYPT
	----------------
	Functia primeste doua argumente: adresa unui sir si lungimea acestuia.
Fiecare caracter al sirului este decriptat realizand operatia XOR intre acesta
si cheia de decriptare 0xAA (170). Decriptarea are loc in place, mesajul plain
regasindu-se la sfarsit la aceeasi adresa ca sirul initial. 
	DECRYPT nu returneaza nicio informatie relevanta.  	
	
	.text:0x08048871 - PRINT_WELCOME   
	----------------
	Afiseaza mesajul de bun-venit (acesta este un string ce se gaseste la 
adresa .data:0804A280), nu primeste niciun argument si nici nu returneaza o 
informatie relevanta.
	
	.text:0x08048883 - PRINT_OPTIONS
	----------------	
	Afiseaza textul corespunzator optiunilor ce pot fi alese de utilizator
. Acest string se regaseste la adresa .data:0x0804A300. Functia nu primeste 
argumente si nu returneaza nimic.

	.text:0x0804893A - CHOOSE_OPTION
	----------------
	Aceasta functie permite introducerea unei cifre cuprinse intre 0 si 5,
corespunzatoare optiunii alese de utilizator. O putem privi sub forma unui 
switch cu 6 cazuri. Cazul "default" va printa la stdout mesajul 
"Unknown option.", folosind puts.  
	Ea nu primeste niciun argument si nici nu intoarce un
rezultat, ci apeleaza alte functii, depinzand de cifra introdusa (OPTION_0,
..., OPTION_4).
	Daca optiunea aleasa este 5, se apeleaza functia externa exit, care va 
termina programul.

	.text:0x08048679 - OPTION_0
	----------------
	Afiseaza mesajul "Enter the valid serial: " si permite introducerea 
unui serial key de maximum 32 de caractere. La randul ei, apeleaza functia de 
la adresa .text:0x08058A5D (CHECK_SERIAL_KEY). 
	Daca serial key-ul introdus este corect, se afiseaza mesajul "Correct!"
In caz contrar la iesire va fi afisat "Nope, try again.". Verificarea se face 
testand daca registrul EAX contine valoarea 0.
      	Functia nu primeste niciun argument si nu returneaza nimic (continutul
registrului EAX nu este relevant pentru functia apelanta).

	.text:0x08048A5D - CHECK_SERIAL_KEY
	----------------
	Functie care primeste ca argument adresa sirului serial key introdus 
anterior. Scopul acesteia este sa testeze efectiv corectitudinea lui. Valoarea 
pe care o intoarce este 1, daca serial key-ul este corect, 0 altfel. 
	Orice serial key incorect va determina ca valoarea din registrul EAX 
(si implicit ceea ce returneaza functia) sa fie setata la 0.
	Se parcurge caracter cu caracter sirul (serial key) si se testeaza daca
fiecare caracter verifica anumite conditii. Orice caracter gresit in sir va 
pastra ZERO FLAG neactivat (ZF = 0). Continutul registrului EFLAGS este salvat 
pe stiva si este apelata functia de adresa .text:0x08048A52 (RESET_EAX). Daca
continutul lui EAX va deveni 0 in urma oricaruia dintre aceste apeluri, este 
clar ca serialul nu este corect.
	CHECK_SERIAL_KEY apeleaza functia de la adresa .text:0x08048A20 
(RESET_REGISTERS). Mai jos se regaseste explicatia acesteia (urmatoarea functie
documentata).
	O alta functie care este apelata de CHECK_SERIAL_KEY este cea de la
adresa .text:0x08048A29 (MODIFY_DL). Si aceasta va seta EAX la valoarea 0
pentru un caracter din serial key incorect. 
	De remarcat este faptul ca in cazul meu se considera ca lungimea serial
key-ului este 15 caractere (posibil lungimea sirului "SmeuFlorin322CD"). 
	Dupa procesarea celor 15 caractere din sir,  o noua verificare este 
efectuata: se testeaza daca suma lor este 0x458 (1112). Identificam aici un 
BUG: se pot introduce si alte caractere dupa un serial key corect, se va 
returna tot 1 (serial key corect). 

	.text:0x08048A20 - RESET_REGISTERS      
	----------------
	Are rolul de a reseta anumiti registri (AH, ECX, EDX, ESI). Acestia 
sunt folositi in funcita apelanta (CHECK_SERIAL_KEY) pentru a stocarea de 
caractere din sirul serial key. Este necesara golirea registrelor in cauza
pentru a putea procesa alte caractere in continuare (orice informatie ramasa
ar influenta verificarea corectitudinii caracterelor urmatoare din serial key). 
	Functia nu primeste niciun argument si returneaza valoarea 0 (serial
key incorect) sau 1 (serial key corect).
 
	.text:0x08048A52 - RESET_EAX
	----------------
	Aceasta functie primeste ca argument continutul registrului EFLAGS si 
seteaza la 0 valoarea registrului EAX, daca ZERO FLAG este nesetat (ZF = 0). 
Altfel, continutul registrului EAX ramane nemodificat. Un serial key corect nu
ar trebui sa modifice niciodata valoarea 1 salvata initial in EAX. 
	Se returneaza 0 sau 1, in functie de corectitudinea serial key-ului. 	

	.text:0x08048A29 - MODIFY_DL
	----------------
	Functia nu primeste niciun argument. Este o functie auxiliara in 
procesul de verificare a corectitudinii serialului, realizand anumite teste
pentru caracterul din serial care se regaseste in registrul DL. Daca acesta 
este un  caracter incorect, functia va returna valoarea 0 (deci va seta
continutul lui EAX la 0).

-------------------------------------------------------------------------------
Pe langa aceste functii, care au fost utile in determinarea unui serial key 
corect, documentam si urmatoarele functii:

	.text:0x080486EA - OPTION_1
	----------------
	Este functia care permite introducerea numelui user-ului. Initial, se 
afiseaza stringul "Enter desired username: " la stdout. Apoi se asteapta 
introducerea numelui dorit. 
	Se utilizeaza pentru citire functia externa isoc99_scanf, care nu va 
lua in considerare decat maximum 20 de caractere, dupa care va adauga un byte 
null terminator. Astfel, daca se introduc 20 de caractere (sau mai mult), 
byte-ul null terminator va suprascrie un byte din adresa EBP care se afla
salvata pe stiva, generandu-se astfel segmentation fault (se acceseaza o adresa
invalida). Totusi, acest lucru nu poate fi exploatat in niciun fel.
	Functia nu returneaza si nu primeste ca argument nimic.

	.text:0x08048710 - OPTION_2
	----------------    
  	Permite introducerea adresei utilizatorului. Se afiseaza mesajul "Enter
desired address: " si se asteapta introducerea adresei dorite.
	Utilizand tot isoc99_scanf, vom putea introduce maximum 20 de 
caractere, putand modifica doar adresa EBP salvata pe stiva. Nu putem afecta in
vreun fel adresa de return a functiei.
	
	.text:0x08048710 - OPTION_3
	----------------
	Functia care permite introducerea unei chei pentru deblocarea seifului.
Pe stiva se aloca spatiu pentru un buffer de 4 octeti. Totusi, citirea se face
folosind functia read, si se vor putea introduce maximum 24 de octeti, ceea ce 
va determina o vulnerabilitate despre care voi vorbi in cadrul task-ului 2.

	.text:0x080485EB - CHECK_SUM
	----------------
	Aceasta functie primeste ca parametru adresa unui sir. Se realizeaza
suma primelor 1023 de caractere ale sirului si in cazul in care aceasta
este egala cu 0x12345 (74565), valoarea returnata este 1. Altfel, functia va 
returna 0. 

	.text:0x0804874E - OPTION_4
	----------------
	Se verifica daca seiful a fost deblocat. Exista 3 variabile globale 
in sectiunea .data al caror continut este 1. Exploatand o vulnerabilitate de
tip buffer overflow, continutul lor trebuie setat la 0, altfel puzzle-ul nu va
putea fi rezolvat.
	In cadrul functiei se apeleaza functia .text:0x08048635 (DECRYPT), 
avand ca parametru o zona din sectiunea .data. Se va decripta astfel o noua 
functie care va contine o vulnerabilitate documentata in task 2. 
	Este necesara introducerea unui sir 1024 de caractere a carui suma sa
fie egala cu 0x12345 (se apeleaza functia de la adresa .text:0x080485EB 
(CHECK_SUM)) pentru a debloca seiful.
	Ulterior, se va verifica daca sirul de 1024 de caractere introdus
contine numele si prenumele folosite pentru a genera executabilul ("Smeu", 
"Florin"). Acest sir trebuie folosit si ca payload, exploatand a doua
vulnerabilitate buffer overflow descrisa in sectiunea urmatoare. 



	TASK 2 - Identificare vulnerabilitati
	=====================================	
	
	VULNERABILITATE 1
	-----------------

In cadrul functiei .text:0x08048710 (OPTION_3) este alocat spatiu pe stiva
pentru 4 octeti. Vulneralilitatea consta in faptul ca se pot citi maximum 24 de 
octeti. Stiva arata in felul urmator:

	   adresa mare 	  --------------------
			  |		     |	
			  |        ...	     |  <- 12 bytes
		^	  |		     |		
		|	  --------------------
		|	  |   adresa return  |  <- 4 bytes	
		|	  --------------------
		|	  |    EBP salvat    |  <- 4 bytes
	  	 	  --------------------
	      		  |      buffer	     |  <- 4 bytes	
	   adresa mica	  --------------------	

Citind cel putin 12 bytes (buffer overflow), adresa de return a functiei poate 
fi suprascrisa, in acest mod alterandu-se fluxul normal al programului. 

	VULNERABILITATE 2
	-----------------

O alta vulnerabilitate se afla in functia .text:0x0804874E (OPTION_4). In 
interiorul ei se apeleaza functia .text:0x08048635 (DECRYPT) avand ca argumente
adresa unui sir si lungimea de 0x400 (1024) caractere. Am observat ca in 
sectiunea .data exista 6 linii care arata in felul urmator: 
	
	.data:0804A264 dword_804A264   dd 2B4F23FFh        
	.data:0804A268 dword_804A268   dd 0AAA94246h        
	.data:0804A26C dword_804A26C   dd 0DF2156AAh           
	.data:0804A270 dword_804A270   dd 134D23A2h           
	.data:0804A274 dword_804A274   dd 0AAAAAEAAh           
	.data:0804A278 dword_804A278   dd 69630E59h

Deoarece functia DECRYPT efectueaza XOR cu cheia 0xAA (170), dupa aceasta 
operatie am asezat little endian octetii si, asambland acest cod masina, am 
obtinut urmatorul cod assembly:  

0:  55                      push   ebp
1:  89 e5                   mov    ebp, esp
3:  81 ec e8 03 00 00       sub    esp, 0x3e8
9:  fc                      cld
a:  8b 75 08                mov    esi, DWORD PTR [ebp+0x8]
d:  89 e7                   mov    edi, esp
f:  b9 00 04 00 00          mov    ecx, 0x400
14: f3 a4                   rep movs BYTE PTR es:[edi], BYTE PTR ds:[esi]
16: c9                      leave
17: c3                      ret 

Aceasta este o functie care primeste un argument (Cel mai probabil, adresa de 
inceput a buffer-ului de 1024 octeti alocat in OPTION_4). Se aloca pe stiva 
un nou buffer cu capacitate de 0x3e8 (1000) bytes. Ulterior, sunt copiati 0x400
(1024) de bytes de la adresa argumentului functiei in bufferul nou creat. 
	In acest mod adresa de return EBP salvat pe stiva, adresa de return a
functiei si alti 16 bytes vor fi suprascrisi. Asadar, un sir de 1024 de 
caractere introdus la optiunea 4 va putea fi folosit ca payload, se va face 
buffer overflow si fluxul programului va fi alterat. 
	Stiva functiei nou-descoperite arata (cel mai probabil) astfel:
	   
   adresa mare            --------------------	
			  |		     |
			  |	  ...	     |	
			  |	  	     |	
	^ 	          --------------------
	|	  ESI ->  | buffer OPTION_4  |	<- 1024 bytes	
	|	 	  --------------------
	|		  |   adresa return  |  <- 4 bytes	
	|	  	  --------------------
			  |    EBP salvat    |  <- 4 bytes
	  	 	  --------------------
	      	  EDI ->  | buffer nou alocat|  <- 1000 bytes	
   adresa mica	  	  --------------------	



	TASK 3 - EXPLOATARE
	===================

Pentru a debloca seiful, propunem urmatorul vector de atac:
	
	1) Exploatam vulnerabilitatea 1 (descrisa in sectiunea anterioara).
Exista trei functii in care in mod obisnuit nu se ajunge niciodata. Aceste
functii seteaza la 0 variabilele globale de la adresele: 
	- .data:0x0804A254 (VAR_1),  
	- .data:0x0804A258 (VAR_2),
	- .data:0x0804A24C (VAR_3).
Functiile sunt urmatoarele: 
	
	.text:0x08048895 - FUNC_1
	---------------- 	
	Seteaza la 0 continutul variabilei globale .data:0x0804A254 (VAR_1).

	.text:0x080488BA - FUNC_2
	----------------
	Seteaza la 0 continutul variabilei globale .data:0x0804a258 (VAR_2), 
daca argumentul primit este 0xDEADC0DE. Din acest motiv, trebuie apelata 
punand pe stiva aceasta valoare mai intai.

	.text:0x080488EA - FUNC_3
	----------------
	Seteaza la 0 continutul variabilei globale .data:0x0804a25C (VAR_3) 
daca se respecta conditiile urmatoare:
	- suma celor doua argumente pe care le primeste este 0xDEADBEEF,
	- diferenta acestora este 0x13371337.
Rezolvand sistemul, obitnem ca argumentele trebuie sa fie: 
	0x78F26913 (ARG_1) si 0x65BB55DC (ARG_2).
	
Payloadul folosit pentru a seta primele 2 variabile globale la 0 este:
			
	+-----------------------------------------------------+
	| aaaa | aaaa | FUNC_1 | FUNC_2 | OPTION_3 | DEADC0DE |
	+-----------------------------------------------------+ 
	<------------>|<------>|<------>|<-------->|<---------> 
	       8 	  4	   4         4           4       (bytes),	
					
adresele functiilor si parametrul 0xDEADC0DE fiind reprezentate little endian.
	In acest moment, ne aflam in functia OPTION_3 si putem introduce din 
nou 24 de bytes pentru a seta si VAR_3 la 0. Vom concatena payload-ul anterior
cu urmatorul:
	
	+-----------------------------------------------------+
	| aaaa | aaaa | FUNC_3 | OPTION_4 | ARG_1  |  ARG_2   |
	+-----------------------------------------------------+ 
	<------------>|<------>|<-------->|<------>|<---------> 
	       8 	  4	   4         4           4       (bytes),
               
unde ARG_1 = 0x78F26913 si ARG_2 = 0x65BB55DC. In acest moment, toate cele 3 
variabile globale au valoarea 0 si poate fi introdus sirul de 1024 de caractere
pentru a exploata a doua vulnerabilitate.
-------------------------------------------------------------------------------

	2) Se exploateaza vulnerabilitatea 2. Este posibil ca unele 
rationamente sa nu fie corecte. Pentru aceasta parte nu am gasit un payload 
care sa afiseze mesajul "Win!". 
	Prima cerinta este ca  sirul introdus sa aiba suma valorilor octetilor
egala cu 0x12345. Apoi, el trebuie contina numele si prenumele folosite in 
generarea executabilului ("Smeu", "Florin").
	In cadrul functiei .text:0x0804874E (OPTION_4) se apeleaza functia 
.text:0x08048635 (DECRYPT) pentru a decripta o zona din sectiunea .data. Daca 
sirul a verificat conditiile din alineatul anterior, se va apela functia 
mprotect pentru a face ca zona decriptata in sectiunea .data sa devina 
executabila. Apoi se va apela aceasta functie (descrisa in sectiunea task 2).
	Functia va suprascrie adresa de return cu 4 bytes din sirul de 1024 
caractere, precum si alti 16 bytes de la inceputul lui, dupa cum se observa in 
schema de mai jos a stivei:

	INAINTE:

      adresa mica            ----------------->              adresa mare  

	+------------------------------------------------------------+
   	|   buffer   | ebp salvat | adr. return	| sir 1024 caractere |
 	+------------------------------------------------------------+	
 	<----------->|<---------->|<----------->|<------------------->	
	     1000          4             4               1024        (bytes),
	   		

	DUPA:

      adresa mica            ----------------->              adresa mare  

	+------------------------------------------------------------+
   	|   buffer   |    B. O.   |    B. O.    | B. O. |    sir     | 
 	+------------------------------------------------------------+	
 	<----------->|<---------->|<----------->|<----->|<----------->	
	     1000          4             4         16        1008   (bytes),
	
	(B. O. = buffer overflow)
 
Este necesar ca adresa de return sa fie suprascrisa cu adresa functiei de la
adresa .text:0x0804882b	(WIN_FUNC), caci in cadrul ei se afiseaza mesajul 
"Win!". 
	Tot in interiorul WIN_FUNC se citesc 4 octeti dintr-o zona de memorie
neinitializata (.bss:0x0804A3E8) si, dupa anumite prelucrari se testeaza daca 
aceasta valoare este egala cu 1 (continutul variabilei globale 
.data:0x0804A260 (VAR_4)).
	Putem rezolva acest inconvenient injectand sub forma shellcode functia 
urmatoare:

injected:
	push		ebp
	mov		ebp, esp
	mov 		DWORD PTR .bss:0x0804A3E8, 0x0
	mov 		DWORD PTR .data:0x0804A260, 0x0
	leave
	ret
	call		injected		
	 		
Am setat continutul ambelor zone de memorie la 0. In acest mod, s-ar afisa 
mesajul "Win!". Codul injectat trebuie sa faca parte din sirul de 1024 de 
caractere introdus in cadrul OPTION_4. In apelul "call injection", "injection"
este adresa de unde incepe codul injectat propriu-zis (zona "push ebp").  
